#!/usr/bin/env python3

"""

This is basically what the frontend is, if that's even correct terminology.

Handles arguments and passes them to the functions.

"""

import argparse
import os
import sys

from img3 import img3
#from img4 import img4
from iphonewiki import iPhoneWiki
from ipswapi import APIParser
from manifest import Manifest
from template import Template
from tss import TSS
from utils import clean, splitKbag

#from pymobiledevice import syslog


def main():
    argv = sys.argv

    parser = argparse.ArgumentParser(usage=f'{argv[0]} <option> <args>')
    parser.add_argument("--buildid", help="Convert an iOS to its buildid", nargs=2, metavar=('DEVICE', 'iOS'))
    parser.add_argument("--baseband", help="Get the baseband version of an iOS", nargs=2, metavar=('DEVICE', 'iOS'))
    parser.add_argument("--clean", help="If there are any leftover json files, this will get rid of them", action='store_true')
    parser.add_argument("--codename", help="Get the codename of an iOS", nargs=2, metavar=('DEVICE', 'iOS'))
    parser.add_argument("--download", help="Download an ipsw", nargs=2, metavar=('DEVICE', 'iOS'))
    parser.add_argument("--keys", help="Get keys for an iOS", nargs=2, metavar=('DEVICE', 'iOS'))
    parser.add_argument("--manifest", help="Download a build manifest from an iOS", nargs=2, metavar=('DEVICE', 'iOS'))
    parser.add_argument("--signed", help="Print the signed iOS versions for a device", nargs=1, metavar='DEVICE')
    parser.add_argument("--shsh", help="Save shsh for all signed iOS versions", action='store_true')
    parser.add_argument("--split", help="Split a GID decrypted key", nargs=1, metavar='KEY')
    parser.add_argument("--tags", help="Print the tags and their hex positions of an img3 file", nargs=1, metavar='FILE')
    parser.add_argument("--template", help="Template parsing", action='store_true')

    args = parser.parse_args()

    if args.buildid:
        api = APIParser(argv[2], argv[3])
        print(api.iOSToBuildid())  # ./yeet --buildid device version

    elif args.baseband:
        # manifest = Manifest(argv[2], argv[3])
        # manifest.getBasebandVersion()  # ./yeet --baseband device version
        pass

    elif args.clean:
        clean()

    elif args.codename:
        manifest = Manifest(argv[2], argv[3])
        print(manifest.getCodename())

    elif args.download:
        api = APIParser(argv[2], argv[3])
        api.downloadIPSW()  # ./yeet --download device version

    elif args.keys:
        wiki = iPhoneWiki(argv[2], argv[3])
        wiki.getWikiKeys()  # ./yeet --keys device version

    elif args.signed:
        api = APIParser(argv[2], None)  # ./yeet --signed device
        data = api.signed()
        for stuff in data:
            print(f'iOS: {stuff[0]} ({stuff[1]}) ({stuff[2]})')

    elif args.manifest:
        manifest = Manifest(argv[2], argv[3])  # ./yeet --manifest device version
        manifest.downloadBuildManifest()

    elif args.shsh:
        # TODO Fix this. It's somewhat cleaner, but this is still bad. May have to use list because dict don't allow duplicate key values
        devices = {
            'iPhone3,1': '806884279284',
            'iPhone3,3': '2902611023180',
            # 'iPhone4,1': ('2271501886349', '2622681783562'),
            'iPhone5,1': '3312880722830',
            'iPhone5,2': '2760926895370',
            'iPhone5,3': '2781026528712',
            'iPhone6,1': '784041742804',
            'iPhone7,2': '360803830744102',
            'iPhone9,4': '5683998923293478',
            'iPhone11,6': '5072064894468154'
        }

        for device, ecid in devices.items():
            data = TSS(device, ecid)
            data.saveBlobsWithTSSChecker()

    elif args.split:
        print(splitKbag(str(argv[2])))  # ./yeet --split kbag

    elif args.tags:
        image = img3(argv[2])
        image.printTags()

    elif args.template:
        pass

    else:
        sys.exit(parser.print_help(sys.stderr))


if __name__ == '__main__':
    main()
